#!/usr/bin/env python3
# scripts/coverage_report.py
# ============================================================================
# Module: Coverage Report Generator
# Description: Generate Decision Gate system-test coverage docs.
# Purpose: Turn registry + gaps into published documentation.
# Dependencies: stdlib, tomllib (or toml)
# ============================================================================

from __future__ import annotations

import argparse
import sys
from datetime import datetime
from datetime import timezone
from pathlib import Path
from typing import Any, Dict, List, MutableMapping

try:
    import tomllib as toml  # Python 3.11+
except ModuleNotFoundError:  # pragma: no cover
    try:
        import toml  # type: ignore
    except ModuleNotFoundError:
        print("Error: tomllib not available. Install 'toml' with: pip install toml")
        sys.exit(1)

RegistryData = MutableMapping[str, Any]


def load_toml(path: Path) -> RegistryData:
    if not path.exists():
        raise FileNotFoundError(f"TOML file not found: {path}")
    return toml.loads(path.read_text(encoding="utf-8"))


def render_table(headers: List[str], rows: List[List[str]]) -> str:
    line = "| " + " | ".join(headers) + " |"
    sep = "|" + "|".join([" --- " for _ in headers]) + "|"
    out = [line, sep]
    for row in rows:
        out.append("| " + " | ".join(row) + " |")
    return "\n".join(out)


def generate_coverage_report(registry: RegistryData, gaps: RegistryData) -> str:
    tests = list(registry.get("tests", []))
    categories = registry.get("categories", {})
    gap_entries = list(gaps.get("gaps", []))

    by_category: Dict[str, int] = {}
    for test in tests:
        by_category[test.get("category", "unknown")] = by_category.get(test.get("category", "unknown"), 0) + 1

    p0_tests = [test for test in tests if test.get("priority") == "P0"]
    p1_tests = [test for test in tests if test.get("priority") == "P1"]
    p2_tests = [test for test in tests if test.get("priority") == "P2"]

    gap_open = [gap for gap in gap_entries if gap.get("status") != "closed"]

    rows = []
    for test in p0_tests:
        rows.append([
            test["name"],
            test.get("category", "unknown"),
            str(test.get("estimated_runtime_sec", 0)),
            f"`{test.get('run_command', '')}`",
        ])

    category_rows = [[cat, str(count), categories.get(cat, {}).get("description", "-")] for cat, count in sorted(by_category.items())]

    gap_rows = []
    for gap in gap_open:
        gap_rows.append([
            gap.get("id", ""),
            gap.get("title", ""),
            gap.get("priority", ""),
            gap.get("category", ""),
            gap.get("status", ""),
        ])

    report = f"""# Decision Gate System-Test Coverage (Auto-Generated)

**Generated:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC
**Source:** system-tests/test_registry.toml + system-tests/test_gaps.toml

> This document is auto-generated by `scripts/coverage_report.py`.

## Executive Summary

- **Total Tests:** {len(tests)}
- **P0:** {len(p0_tests)}
- **P1:** {len(p1_tests)}
- **P2:** {len(p2_tests)}
- **Categories:** {len(by_category)}
- **Open Gaps:** {len(gap_open)}

## P0 Tests

{render_table(["Test", "Category", "Est. Runtime (s)", "Run Command"], rows)}

## Category Coverage

{render_table(["Category", "Tests", "Description"], category_rows)}

"""

    if gap_rows:
        report += "\n## Open Gaps\n\n"
        report += render_table(["ID", "Title", "Priority", "Category", "Status"], gap_rows)
        report += "\n"

    return report


def generate_infrastructure_guide(registry: RegistryData) -> str:
    categories = registry.get("categories", {})
    category_rows = [
        [cat, info.get("description", "-"), "yes" if info.get("quick") else "no"]
        for cat, info in categories.items()
    ]

    guide = f"""# Decision Gate Test Infrastructure Guide (Auto-Generated)

**Generated:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC

> This document is auto-generated by `scripts/coverage_report.py`.

## Overview

System-tests are registry-driven. Every test is declared in
`system-tests/test_registry.toml` and all known gaps live in
`system-tests/test_gaps.toml`.

## Running Tests

```bash
python scripts/test_runner.py --priority P0
python scripts/test_runner.py --category runpack
```

## Environment Variables

- `DECISION_GATE_SYSTEM_TEST_RUN_ROOT`: per-test artifact root (set by runner)
- `DECISION_GATE_SYSTEM_TEST_HTTP_BIND`: optional bind override
- `DECISION_GATE_SYSTEM_TEST_PROVIDER_URL`: optional external provider URL
- `DECISION_GATE_SYSTEM_TEST_TIMEOUT_SEC`: optional timeout override

## Category Index

{render_table(["Category", "Description", "Quick"], category_rows)}

## Artifact Contract

Each system-test emits at least:
- `summary.json`
- `summary.md`
- `tool_transcript.json`

Runpack tests also emit `runpack/` with exported artifacts.

## Hygiene Rules

- No fail-open checks.
- No sleeps for correctness (use readiness probes).
- Use canonical types from production crates.
- Always update the test registry when adding or removing tests.
"""
    return guide


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate Decision Gate test coverage docs")
    parser.add_argument("action", choices=["generate"], help="Generate documentation")
    args = parser.parse_args()

    workspace_root = Path(__file__).resolve().parents[1]
    registry_path = workspace_root / "system-tests" / "test_registry.toml"
    gaps_path = workspace_root / "system-tests" / "test_gaps.toml"
    out_dir = workspace_root / "Docs" / "testing"
    out_dir.mkdir(parents=True, exist_ok=True)

    registry = load_toml(registry_path)
    gaps = load_toml(gaps_path)

    coverage = generate_coverage_report(registry, gaps)
    infra = generate_infrastructure_guide(registry)

    (out_dir / "decision_gate_test_coverage.md").write_text(coverage, encoding="utf-8")
    (out_dir / "test_infrastructure_guide.md").write_text(infra, encoding="utf-8")

    print(f"Wrote: {out_dir / 'decision_gate_test_coverage.md'}")
    print(f"Wrote: {out_dir / 'test_infrastructure_guide.md'}")


if __name__ == "__main__":
    main()
